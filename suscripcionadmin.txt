// roshi_fit/backend/src/controllers/subscriptionController.ts
import { Request, Response } from 'express';
import { prisma } from '../app';

// Utilidad: suma días a una fecha (sin mutar el original)
const addDays = (date: Date, days: number) => {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
};

// Utilidad: normaliza fecha a 00:00:00 local (para campos @db.Date)
const startOfDay = (date: Date) => {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  return d;
};

// GET /api/subscriptions
// Lista la suscripción más reciente por usuario (cliente), con filtros y ordenamiento por días restantes
export const getLatestSubscriptionsPerUser = async (req: Request, res: Response) => {
  try {
    const { search, planId, estado, orderDays } = req.query as {
      search?: string;
      planId?: string;
      estado?: 'activa' | 'vencida' | 'cancelada' | 'suspendida';
      orderDays?: 'asc' | 'desc';
    };

    const today = startOfDay(new Date());

    // Construir where de forma dinámica, devolviendo SIEMPRE la última por usuario para el estado requerido
    let where: any = {
      ...(planId ? { plan_id: parseInt(planId) } : {}),
      usuarios_suscripciones_usuario_usuario_idTousuarios: {
        tipo_usuario: 'cliente',
        estado: 'activo',
      },
    };

    if (estado) {
      if (estado === 'vencida') {
        // Vencidas por fecha: incluir aunque la suscripción esté inactiva, para no perder históricos
        where = { ...where, fecha_fin: { lt: today } };
      } else if (estado === 'activa') {
        // Activas: deben estar activas y no vencidas por fecha
        where = { ...where, estado: 'activo', estado_suscripcion: 'activa', fecha_fin: { gte: today } };
      } else {
        // cancelada | suspendida: mantener estado 'activo' del registro
        where = { ...where, estado: 'activo', estado_suscripcion: estado };
      }
    } else {
      // Vista general: mantener solo registros activos por defecto
      where = { ...where, estado: 'activo' };
    }

    const raw = await prisma.suscripciones_usuario.findMany({
      where,
      orderBy: [
        { usuario_id: 'asc' },
        { fecha_inicio: 'desc' },
      ],
      distinct: ['usuario_id'],
      include: {
        usuarios_suscripciones_usuario_usuario_idTousuarios: {
          select: { id: true, nombre_completo: true, email: true, telefono: true }
        },
        planes_suscripcion: {
          select: { id: true, nombre: true, precio_q: true, duracion_dias: true }
        },
      },
    });

    // Mapear y calcular días restantes + estado calculado
    let data = raw.map((s) => {
      const fin = startOfDay(new Date(s.fecha_fin));
      const msDiff = fin.getTime() - today.getTime();
      const dias_restantes = Math.max(0, Math.floor(msDiff / (1000 * 60 * 60 * 24)));
      const computed_estado = fin.getTime() < today.getTime() ? 'vencida' : s.estado_suscripcion;

      return {
        id: s.id,
        usuario_id: s.usuario_id,
        plan_id: s.plan_id,
        fecha_inicio: s.fecha_inicio,
        fecha_fin: s.fecha_fin,
        estado_suscripcion: s.estado_suscripcion,
        dias_restantes,
        computed_estado,
        usuario: s.usuarios_suscripciones_usuario_usuario_idTousuarios,
        plan: s.planes_suscripcion,
      };
    });

    // Filtro por search (nombre o email) del lado del servidor (sobre el resultado ya agrupado por usuario)
    if (search && search.trim() !== '') {
      const term = search.trim().toLowerCase();
      data = data.filter((item) =>
        item.usuario.nombre_completo.toLowerCase().includes(term) ||
        item.usuario.email.toLowerCase().includes(term)
      );
    }

    // Ordenamiento por días restantes
    if (orderDays === 'asc') {
      data.sort((a, b) => a.dias_restantes - b.dias_restantes);
    } else if (orderDays === 'desc') {
      data.sort((a, b) => b.dias_restantes - a.dias_restantes);
    }

    res.json(data);
  } catch (error) {
    console.error('Error al listar suscripciones:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
};

// PATCH /api/subscriptions/:id/extend { dias: number }
export const extendSubscription = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { dias } = req.body as { dias: number };

    const diasNum = parseInt(String(dias));
    if (!diasNum || diasNum <= 0) {
      return res.status(400).json({ message: 'El número de días debe ser mayor a 0.' });
    }

    const existing = await prisma.suscripciones_usuario.findUnique({ where: { id: parseInt(id) } });
    if (!existing || existing.estado !== 'activo') {
      return res.status(404).json({ message: 'Suscripción no encontrada o inactiva.' });
    }

    const newEnd = addDays(new Date(existing.fecha_fin), diasNum);

    const updated = await prisma.suscripciones_usuario.update({
      where: { id: parseInt(id) },
      data: { fecha_fin: startOfDay(newEnd) },
      select: { id: true, fecha_inicio: true, fecha_fin: true }
    });

    res.json({ message: 'Suscripción extendida.', suscripcion: updated });
  } catch (error) {
    console.error('Error al extender suscripción:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
};

// PATCH /api/subscriptions/:id/cancel
export const cancelSubscription = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const existing = await prisma.suscripciones_usuario.findUnique({ where: { id: parseInt(id) } });
    if (!existing || existing.estado !== 'activo') {
      return res.status(404).json({ message: 'Suscripción no encontrada o inactiva.' });
    }

    const updated = await prisma.suscripciones_usuario.update({
      where: { id: parseInt(id) },
      data: { estado_suscripcion: 'cancelada' },
      select: { id: true, estado_suscripcion: true }
    });

    res.json({ message: 'Suscripción cancelada.', suscripcion: updated });
  } catch (error) {
    console.error('Error al cancelar suscripción:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
};

// POST /api/subscriptions/renew
// body: { usuario_id, plan_id, metodo_pago_id, detalles? }
export const renewSubscription = async (req: Request, res: Response) => {
  try {
    const { usuario_id, plan_id, metodo_pago_id, detalles } = req.body as {
      usuario_id: number;
      plan_id: number;
      metodo_pago_id: number;
      detalles?: any;
    };

    if (!usuario_id || !plan_id || !metodo_pago_id) {
      return res.status(400).json({ message: 'usuario_id, plan_id y metodo_pago_id son obligatorios.' });
    }

    const [user, plan, latest] = await Promise.all([
      prisma.usuarios.findUnique({ where: { id: Number(usuario_id) } }),
      prisma.planes_suscripcion.findUnique({ where: { id: Number(plan_id) } }),
      prisma.suscripciones_usuario.findFirst({
        where: { usuario_id: Number(usuario_id), estado: 'activo' },
        orderBy: { fecha_inicio: 'desc' },
      })
    ]);

    if (!user || user.tipo_usuario !== 'cliente' || user.estado !== 'activo') {
      return res.status(400).json({ message: 'Usuario inválido para renovación.' });
    }
    if (!plan || plan.estado !== 'activo') {
      return res.status(400).json({ message: 'Plan no válido para renovación.' });
    }

    const today = startOfDay(new Date());
    let startDate = today;
    if (latest) {
      const latestEnd = startOfDay(new Date(latest.fecha_fin));

      if (latest.estado_suscripcion === 'cancelada') {
        // Si la última fue cancelada, NO se suman días restantes; inicia hoy
        startDate = today;
      } else if (latestEnd.getTime() >= today.getTime()) {
        // Renovación antes de vencer: inicia el día siguiente al vencimiento actual
        startDate = addDays(latestEnd, 1);
      } else {
        // Ya venció: inicia hoy
        startDate = today;
      }
    }

    const endDate = addDays(startDate, plan.duracion_dias);

    const result = await prisma.$transaction(async (tx) => {
      // Marcar suscripción anterior como vencida si no estaba cancelada (si existe)
      if (latest && latest.estado_suscripcion !== 'cancelada') {
        await tx.suscripciones_usuario.update({
          where: { id: latest.id },
          data: { estado_suscripcion: 'vencida' },
        });
      }

      // Crear nueva suscripción
      const nueva = await tx.suscripciones_usuario.create({
        data: {
          usuario_id: Number(usuario_id),
          plan_id: Number(plan_id),
          fecha_inicio: startDate,
          fecha_fin: endDate,
          estado_suscripcion: 'activa',
          estado: 'activo',
        },
        select: { id: true, usuario_id: true, plan_id: true, fecha_inicio: true, fecha_fin: true }
      });

      // Registrar transacción de pago
      await tx.transacciones_pago.create({
        data: {
          orden_id: null,
          metodo_pago_id: Number(metodo_pago_id),
          monto_q: plan.precio_q,
          estado_transaccion: 'exitosa',
          detalles: detalles ? detalles : undefined,
          estado: 'activo',
        }
      });

      return nueva;
    });

    res.status(201).json({ message: 'Renovación exitosa.', suscripcion: result });
  } catch (error) {
    console.error('Error al renovar suscripción:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
};

// GET /api/subscriptions/:userId/history
export const getUserSubscriptionHistory = async (req: Request, res: Response) => {
  try {
    const { userId } = req.params;

    const user = await prisma.usuarios.findUnique({ where: { id: Number(userId) } });
    if (!user) return res.status(404).json({ message: 'Usuario no encontrado.' });

    const history = await prisma.suscripciones_usuario.findMany({
      where: { usuario_id: Number(userId), estado: 'activo' },
      orderBy: { fecha_inicio: 'desc' },
      include: {
        planes_suscripcion: { select: { id: true, nombre: true, precio_q: true, duracion_dias: true } }
      }
    });

    res.json(history);
  } catch (error) {
    console.error('Error al obtener historial de suscripciones:', error);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
};


// roshi_fit/backend/src/routes/subscriptionRoutes.ts
import { Router } from 'express';
import {
  getLatestSubscriptionsPerUser,
  extendSubscription,
  cancelSubscription,
  renewSubscription,
  getUserSubscriptionHistory,
} from '../controllers/subscriptionController';

const router = Router();

// Tabla principal con filtros
router.get('/', getLatestSubscriptionsPerUser);

// Acciones
router.patch('/:id/extend', extendSubscription);
router.patch('/:id/cancel', cancelSubscription);
router.post('/renew', renewSubscription);

// Historial por usuario
router.get('/:userId/history', getUserSubscriptionHistory);

export default router;


// roshi_fit/src/api/subscriptionApi.ts
import api from './axiosInstance';

export interface SubscriptionListItem {
  id: number;
  usuario_id: number;
  plan_id: number;
  fecha_inicio: string;
  fecha_fin: string;
  estado_suscripcion: 'activa' | 'vencida' | 'cancelada' | 'suspendida';
  dias_restantes: number;
  computed_estado: 'activa' | 'vencida' | 'cancelada' | 'suspendida';
  usuario: { id: number; nombre_completo: string; email: string; telefono?: string | null };
  plan: { id: number; nombre: string; precio_q: string; duracion_dias: number };
}

export interface RenewPayload {
  usuario_id: number;
  plan_id: number;
  metodo_pago_id: number;
  detalles?: any;
}

export const fetchSubscriptions = async (params?: {
  search?: string;
  planId?: number | string;
  estado?: 'activa' | 'vencida' | 'cancelada' | 'suspendida';
  orderDays?: 'asc' | 'desc';
}) => {
  const res = await api.get<SubscriptionListItem[]>('/subscriptions', { params });
  return res.data;
};

export const extendSubscription = async (id: number, dias: number) => {
  const res = await api.patch(`/subscriptions/${id}/extend`, { dias });
  return res.data;
};

export const cancelSubscription = async (id: number) => {
  const res = await api.patch(`/subscriptions/${id}/cancel`);
  return res.data;
};

export const renewSubscription = async (payload: RenewPayload) => {
  const res = await api.post('/subscriptions/renew', payload);
  return res.data;
};

export const fetchSubscriptionHistory = async (userId: number) => {
  const res = await api.get(`/subscriptions/${userId}/history`);
  return res.data as any[];
};


// roshi_fit/src/types/Subscription.ts
export type SubscriptionStatus = 'activa' | 'vencida' | 'cancelada' | 'suspendida';

export interface Subscription {
  id: number;
  usuario_id: number;
  plan_id: number;
  fecha_inicio: string; // ISO
  fecha_fin: string; // ISO
  estado_suscripcion: SubscriptionStatus;
}

export interface SubscriptionWithUserPlan extends Subscription {
  usuario: { id: number; nombre_completo: string; email: string; telefono?: string | null };
  plan: { id: number; nombre: string; precio_q: string; duracion_dias: number };
  dias_restantes: number;
  computed_estado: SubscriptionStatus;
}


// roshi_fit/src/pages/dashboard/subscriptions/RenewSubscriptionModal.tsx
import React, { useEffect, useState } from 'react';
import type { Plan } from '../../../types/Plan';
import { renewSubscription } from '../../../api/subscriptionApi';
import api from '../../../api/axiosInstance';

interface Props {
  usuarioId: number;
  onClose: () => void;
  onSuccess: () => void;
}

interface PaymentMethod { id: number; nombre: string }

const RenewSubscriptionModal: React.FC<Props> = ({ usuarioId, onClose, onSuccess }) => {
  const [plans, setPlans] = useState<Plan[]>([]);
  const [metodos, setMetodos] = useState<PaymentMethod[]>([]);

  const [planId, setPlanId] = useState('');
  const [metodoPagoId, setMetodoPagoId] = useState('');
  const [detalles, setDetalles] = useState<any>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const load = async () => {
      try {
        const [p, m] = await Promise.all([
          api.get<Plan[]>('/plans/for-registration').then(r => r.data),
          api.get<PaymentMethod[]>('/payment-methods/active').then(r => r.data),
        ]);
        setPlans(p);
        setMetodos(m);
      } catch (e) {
        setError('No se pudieron cargar planes o métodos de pago.');
      }
    };
    load();
  }, []);

  const renderMetodoFields = () => {
    const metodo = metodos.find(m => String(m.id) === metodoPagoId)?.nombre || '';
    switch (metodo) {
      case 'Tarjeta':
        return (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
            <input className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" placeholder="Número de tarjeta" onChange={e=>setDetalles({ ...detalles, numero_tarjeta: e.target.value })} />
            <input className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" placeholder="Titular" onChange={e=>setDetalles({ ...detalles, titular: e.target.value })} />
            <input className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" placeholder="Exp (MM/AA)" onChange={e=>setDetalles({ ...detalles, exp: e.target.value })} />
            <input className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" placeholder="CVV" onChange={e=>setDetalles({ ...detalles, cvv: e.target.value })} />
          </div>
        );
      case 'PayPal':
        return (
          <input className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent w-full" placeholder="Email de PayPal" onChange={e=>setDetalles({ ...detalles, paypal_email: e.target.value })} />
        );
      case 'Depósito Bancario':
        return (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
            <input className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" placeholder="Banco" onChange={e=>setDetalles({ ...detalles, banco: e.target.value })} />
            <input className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" placeholder="Referencia" onChange={e=>setDetalles({ ...detalles, referencia: e.target.value })} />
          </div>
        );
      case 'Efectivo':
      default:
        return null;
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    if (!planId || !metodoPagoId) { setError('Seleccione plan y método de pago.'); return; }
    try {
      setLoading(true);
      await renewSubscription({ usuario_id: usuarioId, plan_id: Number(planId), metodo_pago_id: Number(metodoPagoId), detalles });
      onSuccess();
      onClose();
    } catch (e) {
      setError('Error al renovar suscripción.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-dashboard-accent/90 p-6 rounded-xl shadow-2xl w-full max-w-2xl border border-dashboard-accent" onClick={(e)=>e.stopPropagation()}>
        <div className="flex justify-between items-center mb-4 border-b border-dashboard-accent pb-2">
          <h2 className="text-xl font-bold text-dashboard-text">Renovar Suscripción</h2>
          <button onClick={onClose} className="text-dashboard-text hover:text-dashboard-primary text-2xl">&times;</button>
        </div>

        {error && <div className="bg-red-800/50 text-red-200 p-2 rounded mb-4">{error}</div>}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div>
              <label className="block text-sm text-dashboard-text-secondary mb-1">Plan</label>
              <select className="w-full p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" value={planId} onChange={(e)=>setPlanId(e.target.value)}>
                <option value="">Seleccione plan...</option>
                {plans.map(p=> <option key={p.id} value={p.id}>{p.nombre} - Q{p.precio_q}</option>)}
              </select>
            </div>
            <div>
              <label className="block text-sm text-dashboard-text-secondary mb-1">Método de pago</label>
              <select className="w-full p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent" value={metodoPagoId} onChange={(e)=>setMetodoPagoId(e.target.value)}>
                <option value="">Seleccione método...</option>
                {metodos.map(m=> <option key={m.id} value={m.id}>{m.nombre}</option>)}
              </select>
            </div>
          </div>

          {renderMetodoFields()}

          <div className="flex justify-end gap-3">
            <button type="button" onClick={onClose} className="px-4 py-2 text-dashboard-text hover:text-dashboard-primary">Cancelar</button>
            <button type="submit" disabled={loading} className="px-4 py-2 bg-dashboard-primary text-dashboard-bg font-semibold rounded hover:bg-dashboard-secondary transition-colors">
              {loading ? 'Procesando...' : 'Finalizar'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default RenewSubscriptionModal;

// roshi_fit/src/pages/dashboard/subscriptions/SubscriptionActions.tsx
import React from 'react';

interface Props {
  onExtend: () => void;
  onCancel: () => void;
  onRenew: () => void;
  onHistory: () => void;
}

const SubscriptionActions: React.FC<Props> = ({ onExtend, onCancel, onRenew, onHistory }) => {
  return (
    <div className="flex gap-2">
      <button onClick={onExtend} className="px-2 py-1 bg-blue-600 hover:bg-blue-500 text-white rounded">Extender</button>
      <button onClick={onCancel} className="px-2 py-1 bg-red-600 hover:bg-red-500 text-white rounded">Cancelar</button>
      <button onClick={onRenew} className="px-2 py-1 bg-green-600 hover:bg-green-500 text-white rounded">Renovar</button>
      <button onClick={onHistory} className="px-2 py-1 bg-gray-600 hover:bg-gray-500 text-white rounded">Historial</button>
    </div>
  );
};

export default SubscriptionActions;


// roshi_fit/src/pages/dashboard/subscriptions/SubscriptionsFilters.tsx
import React from 'react';
import type { Plan } from '../../../types/Plan';

interface FiltersProps {
  plans: Plan[];
  values: {
    search: string;
    planId: string;
    estado: '' | 'activa' | 'vencida' | 'cancelada' | 'suspendida';
    orderDays: '' | 'asc' | 'desc';
  };
  onChange: (vals: FiltersProps['values']) => void;
}

const SubscriptionsFilters: React.FC<FiltersProps> = ({ plans, values, onChange }) => {
  const update = (patch: Partial<FiltersProps['values']>) => onChange({ ...values, ...patch });

  return (
    <div className="bg-dashboard-accent/40 p-4 rounded-lg border border-dashboard-accent mb-4 grid grid-cols-1 md:grid-cols-4 gap-3">
      <input
        type="text"
        placeholder="Buscar por nombre o email..."
        className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent"
        value={values.search}
        onChange={(e) => update({ search: e.target.value })}
      />

      <select
        className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent"
        value={values.planId}
        onChange={(e) => update({ planId: e.target.value })}
      >
        <option value="">Todos los planes</option>
        {plans.map((p) => (
          <option key={p.id} value={p.id}>{p.nombre}</option>
        ))}
      </select>

      <select
        className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent"
        value={values.estado}
        onChange={(e) => update({ estado: e.target.value as any })}
      >
        <option value="">Todos los estados</option>
        <option value="activa">Activa</option>
        <option value="vencida">Vencida</option>
        <option value="cancelada">Cancelada</option>
        <option value="suspendida">Suspendida</option>
      </select>

      <select
        className="p-2 bg-dashboard-bg text-dashboard-text rounded border border-dashboard-accent"
        value={values.orderDays}
        onChange={(e) => update({ orderDays: e.target.value as any })}
      >
        <option value="">Ordenar por días restantes</option>
        <option value="asc">Próximos a vencer (asc)</option>
        <option value="desc">Más tiempo restante (desc)</option>
      </select>
    </div>
  );
};

export default SubscriptionsFilters;


// roshi_fit/src/pages/dashboard/subscriptions/SubscriptionsList.tsx
import React, { useEffect, useState } from 'react'; // useMemo
import type { Plan } from '../../../types/Plan';
import type { SubscriptionWithUserPlan } from '../../../types/Subscription';
import api from '../../../api/axiosInstance';
import { cancelSubscription, extendSubscription, fetchSubscriptions } from '../../../api/subscriptionApi';
import SubscriptionsFilters from './SubscriptionsFilters';
import SubscriptionActions from './SubscriptionActions';
import ExtendSubscriptionModal from './ExtendSubscriptionModal';
import RenewSubscriptionModal from './RenewSubscriptionModal';
import SubscriptionHistoryModal from './SubscriptionHistoryModal';

const SubscriptionsList: React.FC = () => {
  const [plans, setPlans] = useState<Plan[]>([]);
  const [items, setItems] = useState<SubscriptionWithUserPlan[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [filters, setFilters] = useState({ search: '', planId: '', estado: '' as any, orderDays: '' as any });

  const [extendId, setExtendId] = useState<number | null>(null);
  const [renewUserId, setRenewUserId] = useState<number | null>(null);
  const [historyUserId, setHistoryUserId] = useState<number | null>(null);

  const load = async () => {
    try {
      setLoading(true);
      const [p, s] = await Promise.all([
        api.get<Plan[]>('/plans/for-registration').then(r=>r.data),
        fetchSubscriptions({
          search: filters.search || undefined,
          planId: filters.planId || undefined,
          estado: filters.estado || undefined,
          orderDays: filters.orderDays || undefined,
        })
      ]);
      setPlans(p);
      setItems(s as any);
    } catch (e) {
      setError('No se pudo cargar la información.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { load(); /* eslint-disable-next-line */ }, [filters.search, filters.planId, filters.estado, filters.orderDays]);

  const handleExtend = async (id: number, dias: number) => {
    try {
      await extendSubscription(id, dias);
      setExtendId(null);
      await load();
    } catch (e) {
      alert('Error al extender suscripción');
    }
  };

  const handleCancel = async (id: number) => {
    if (!confirm('¿Cancelar esta suscripción?')) return;
    try {
      await cancelSubscription(id);
      await load();
    } catch (e) {
      alert('Error al cancelar suscripción');
    }
  };

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold text-dashboard-text mb-4">Suscripciones de Usuarios</h1>

      <SubscriptionsFilters plans={plans} values={filters} onChange={setFilters} />

      {loading && <div className="text-dashboard-text">Cargando...</div>}
      {error && <div className="bg-red-800/50 text-red-200 p-2 rounded mb-4">{error}</div>}

      {!loading && !error && (
        <div className="overflow-x-auto">
          <table className="min-w-full text-sm">
            <thead>
              <tr className="text-left text-dashboard-text-secondary border-b border-dashboard-accent">
                <th className="py-2">Usuario</th>
                <th className="py-2">Teléfono</th>
                <th className="py-2">Plan</th>
                <th className="py-2">Fecha Inicio</th>
                <th className="py-2">Fecha Fin</th>
                <th className="py-2">Días Restantes</th>
                <th className="py-2">Estado</th>
                <th className="py-2">Acciones</th>
              </tr>
            </thead>
            <tbody className="text-dashboard-text">
              {items.map((s) => (
                <tr key={s.id} className="border-b border-dashboard-accent/40">
                  <td className="py-2">
                    <div className="font-semibold">{s.usuario?.nombre_completo}</div>
                    <div className="text-xs text-dashboard-text-secondary">{s.usuario?.email}</div>
                  </td>
                  <td className="py-2">{s.usuario?.telefono || '-'}</td>
                  <td className="py-2">{s.plan?.nombre}</td>
                  <td className="py-2">{new Date(s.fecha_inicio).toLocaleDateString()}</td>
                  <td className="py-2">{new Date(s.fecha_fin).toLocaleDateString()}</td>
                  <td className="py-2">{s.dias_restantes}</td>
                  <td className="py-2 capitalize">{s.computed_estado}</td>
                  <td className="py-2">
                    <SubscriptionActions
                      onExtend={() => setExtendId(s.id)}
                      onCancel={() => handleCancel(s.id)}
                      onRenew={() => setRenewUserId(s.usuario_id)}
                      onHistory={() => setHistoryUserId(s.usuario_id)}
                    />
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {extendId !== null && (
        <ExtendSubscriptionModal
          subscriptionId={extendId}
          onClose={() => setExtendId(null)}
          onExtend={handleExtend}
        />
      )}

      {renewUserId !== null && (
        <RenewSubscriptionModal
          usuarioId={renewUserId}
          onClose={() => setRenewUserId(null)}
          onSuccess={load}
        />
      )}

      {historyUserId !== null && (
        <SubscriptionHistoryModal
          usuarioId={historyUserId}
          onClose={() => setHistoryUserId(null)}
        />
      )}
    </div>
  );
};

export default SubscriptionsList;
